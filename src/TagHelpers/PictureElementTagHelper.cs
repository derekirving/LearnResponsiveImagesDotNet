using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using Microsoft.AspNetCore.Razor.TagHelpers;
using WebUtility = System.Net.WebUtility;

namespace Respond.TagHelpers
{
    /// <summary>
    /// Tag Helper that generates responsive picture elements with multiple image formats and sizes
    /// </summary>
    [HtmlTargetElement("picture", Attributes = "src")]
    public class PictureElementTagHelper(
        IHttpContextAccessor httpContextAccessor,
        IWebHostEnvironment webHostEnvironment)
        : TagHelper
    {
        private static readonly int[] Widths = [1400, 1200, 992, 768, 576];
        //private static readonly string[] Formats = ["avif", "webp"];
        private const int HashLength = 8;
        private static Dictionary<string, string>? _hashManifest;
        private static readonly Lock ManifestLock = new();

        /// <summary>
        /// The source image filename (e.g., "growth.jpg")
        /// </summary>
        [HtmlAttributeName("src")]
        public string Src { get; set; } = string.Empty;

        /// <summary>
        /// Alt text for the image
        /// </summary>
        [HtmlAttributeName("alt")]
        public string Alt { get; set; } = string.Empty;

        /// <summary>
        /// CSS class(es) to apply to the img element
        /// </summary>
        [HtmlAttributeName("class")]
        public string? CssClass { get; set; }

        /// <summary>
        /// ID to apply to the img element
        /// </summary>
        [HtmlAttributeName("id")]
        public string? Id { get; set; }

        /// <summary>
        /// Relative path for generated images (default: "img/generated")
        /// Will be combined with Request.PathBase automatically
        /// </summary>
        [HtmlAttributeName("base-path")]
        public string BasePath { get; set; } = "img/responsive";

        /// <summary>
        /// Source directory for original images (default: "wwwroot/img")
        /// Used to calculate file hashes for cache busting
        /// </summary>
        [HtmlAttributeName("source-path")]
        public string SourcePath { get; set; } = "wwwroot/img";

        /// <summary>
        /// Path to the hash manifest file (default: "wwwroot/img-manifest.json")
        /// Generated by the image processing CLI
        /// </summary>
        [HtmlAttributeName("manifest-path")]
        public string ManifestPath { get; set; } = "wwwroot/img/img-manifest.json";

        /// <summary>
        /// Loading attribute for the img element (lazy, eager, auto)
        /// </summary>
        [HtmlAttributeName("loading")]
        public string? Loading { get; set; }

        /// <summary>
        /// Whether to include AVIF format (default: true)
        /// </summary>
        [HtmlAttributeName("include-avif")]
        public bool IncludeAvif { get; set; } = true;

        /// <summary>
        /// Whether to include WebP format (default: true)
        /// </summary>
        [HtmlAttributeName("include-webp")]
        public bool IncludeWebp { get; set; } = true;

        private void LoadHashManifest()
        {
            if (_hashManifest != null)
            {
                return;
            }

            lock (ManifestLock)
            {
                // Double-check after acquiring lock
                if (_hashManifest != null)
                {
                    return;
                }

                var manifestPath = Path.Combine(webHostEnvironment.ContentRootPath, ManifestPath);
                
                if (!File.Exists(manifestPath))
                {
                    _hashManifest = new Dictionary<string, string>();
                    return;
                }

                try
                {
                    var json = File.ReadAllText(manifestPath);
                    _hashManifest = JsonSerializer.Deserialize<Dictionary<string, string>>(json) 
                        ?? new Dictionary<string, string>();
                }
                catch
                {
                    _hashManifest = new Dictionary<string, string>();
                }
            }
        }

        private string? GetHashFromManifest(string fileName)
        {
            LoadHashManifest();
            
            if (_hashManifest == null || !_hashManifest.TryGetValue(fileName, out var hash))
            {
                // Fallback: calculate hash on-the-fly if not in manifest
                return CalculateFileHashFallback(fileName);
            }

            return hash;
        }

        private string? CalculateFileHashFallback(string fileName)
        {
            try
            {
                var sourceFilePath = Path.Combine(webHostEnvironment.ContentRootPath, SourcePath, fileName);
                
                if (!File.Exists(sourceFilePath))
                {
                    return null;
                }

                using var stream = File.OpenRead(sourceFilePath);
                using var sha256 = SHA256.Create();
                var hashBytes = sha256.ComputeHash(stream);
                var hash = Convert.ToHexStringLower(hashBytes);
                return hash[..HashLength];
            }
            catch
            {
                return null;
            }
        }

        public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
        {
            if (string.IsNullOrWhiteSpace(Src))
            {
                output.SuppressOutput();
                return;
            }

            // Extract filename without extension
            var lastDot = Src.LastIndexOf('.');
            var fileName = lastDot > 0 ? Src[..lastDot] : Src;
            var extension = lastDot > 0 ? Src[lastDot..] : ".jpg";

            // Get file hash from manifest (or calculate as fallback)
            var hash = GetHashFromManifest(Src);
            if (hash == null)
            {
                // If we can't get hash, suppress output to avoid broken images
                output.SuppressOutput();
                return;
            }

            // Build the full base path using Request.PathBase
            var pathBase = httpContextAccessor.HttpContext?.Request.PathBase.Value ?? "";
            var normalizedBasePath = BasePath.TrimStart('/').TrimEnd('/');
            var basePath = string.IsNullOrEmpty(pathBase) 
                ? $"/{normalizedBasePath}" 
                : $"{pathBase}/{normalizedBasePath}";

            output.TagName = "picture";
            output.TagMode = TagMode.StartTagAndEndTag;
            
            // Remove the attributes we've processed
            output.Attributes.RemoveAll("src");
            output.Attributes.RemoveAll("alt");
            output.Attributes.RemoveAll("class");
            output.Attributes.RemoveAll("id");
            output.Attributes.RemoveAll("base-path");
            output.Attributes.RemoveAll("source-path");
            output.Attributes.RemoveAll("manifest-path");
            output.Attributes.RemoveAll("loading");
            output.Attributes.RemoveAll("include-avif");
            output.Attributes.RemoveAll("include-webp");

            var childContent = await output.GetChildContentAsync();

            var contentBuilder = new StringBuilder();

            // Add AVIF source if enabled
            if (IncludeAvif)
            {
                contentBuilder.AppendLine();
                contentBuilder.Append("    <source");
                contentBuilder.AppendLine();
                contentBuilder.Append($"        srcset=\"{BuildSrcset(basePath, fileName, hash, "avif")}\"");
                contentBuilder.AppendLine();
                contentBuilder.Append("        type=\"image/avif\">");
            }

            // Add WebP source if enabled
            if (IncludeWebp)
            {
                contentBuilder.AppendLine();
                contentBuilder.Append("    <source");
                contentBuilder.AppendLine();
                contentBuilder.Append($"        srcset=\"{BuildSrcset(basePath, fileName, hash, "webp")}\"");
                contentBuilder.AppendLine();
                contentBuilder.Append("        type=\"image/webp\">");
            }

            // Add img element with JPG fallback
            contentBuilder.AppendLine();
            contentBuilder.Append("    <img");
            
            if (!string.IsNullOrWhiteSpace(Alt))
            {
                contentBuilder.Append($" alt=\"{WebUtility.HtmlEncode(Alt)}\"");
            }
            
            contentBuilder.Append($" src=\"{basePath}/{fileName}{extension}?h={hash}\"");
            contentBuilder.AppendLine();
            contentBuilder.Append($"        srcset=\"{BuildSrcset(basePath, fileName, hash, "jpg")}\"");

            if (!string.IsNullOrWhiteSpace(Id))
            {
                contentBuilder.AppendLine();
                contentBuilder.Append($"        id=\"{WebUtility.HtmlEncode(Id)}\"");
            }

            if (!string.IsNullOrWhiteSpace(CssClass))
            {
                contentBuilder.AppendLine();
                contentBuilder.Append($"        class=\"{WebUtility.HtmlEncode(CssClass)}\"");
            }

            if (!string.IsNullOrWhiteSpace(Loading))
            {
                contentBuilder.AppendLine();
                contentBuilder.Append($"        loading=\"{WebUtility.HtmlEncode(Loading)}\"");
            }

            contentBuilder.Append('>');
            contentBuilder.AppendLine(childContent.GetContent());

            output.Content.SetHtmlContent(contentBuilder.ToString());
        }

        private static string BuildSrcset(string basePath, string fileName, string hash, string format)
        {
            var srcsetItems = Widths
                .Select(width => $"{basePath}/{fileName}-{width}.{format}?h={hash} {width}w")
                .ToList();

            return string.Join(", ", srcsetItems);
        }
    }
}